<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>PrGlib library by thang19xx</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PrGlib library</h1>
      <h2 class="project-tagline">GENERATE STRONG PRIMES FOR RSA - version 1.5.1 by ducthang</h2>
      <a href="https://github.com/thang19xx/PrGlib" class="btn">View on GitHub</a>
      <a href="https://github.com/thang19xx/PrGlib/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/thang19xx/PrGlib/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><img src="https://raw.githubusercontent.com/thang19xx/PrGlib/master/image.jpg" alt="PrGlib library"></p>

<p>[ENGLISH]-[VIETNAMESE]</p>

<h1>
<a id="generate-strong-primes-for-rsa" class="anchor" href="#generate-strong-primes-for-rsa" aria-hidden="true"><span class="octicon octicon-link"></span></a>GENERATE STRONG PRIMES FOR RSA </h1>

<p><em><a href="https://www.facebook.com/thangdn.sf">thangdn</a></em></p>

<p><em><a href="mailto:thangdn.tlu@outlook.com">thangdn.tlu@outlook.com</a></em></p>

<p><em>ThangLong University</em></p>

<h2>
<a id="i-generation-of-strong-primes" class="anchor" href="#i-generation-of-strong-primes" aria-hidden="true"><span class="octicon octicon-link"></span></a>I. GENERATION OF STRONG PRIMES</h2>

<p><strong><em>According to primes number, the average distance of two large prime numbers (n bit) is  n * ln2. And We prove the existence of primes in this distance.</em></strong></p>

<h3>
<a id="1-generate-random-integers" class="anchor" href="#1-generate-random-integers" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. Generate random integers</strong>
</h3>

<p>We need to generate large random integer about 3072bit. Due to use in cryptography so a good random integer if it satisfies the following condition: it's a large integer. the values between numbers have to far apart.</p>

<p>In this PrGlib library, it was used RandomBits (NTL library) to goal generate random integers.</p>

<h3>
<a id="2-pretreatment" class="anchor" href="#2-pretreatment" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. PRETREATMENT</strong>
</h3>

<p>We'll consider 2<em>n</em>ln2 numbers [n,n+2<em>n</em>ln) by Rabin-miller Algorithm. But we can improve this algorithm as follows:</p>

<blockquote>
<ul>
<li><p>Generate a list 1000 the first prime numbers.</p></li>
<li><p>Generate a array S with size = 2<em>n</em>ln2. default is zero</p></li>
<li><p>Let r=n%p (p is 1000 the first primes). And compute S[p*k-r]=1</p></li>
</ul>
</blockquote>

<p>we prove n+i always be divisible for p if S[i]=1.</p>

<p>After finish, we just consider n+i if S[i]=0.</p>

<p>so this improve algorithm, it eliminates more than 93% composite.</p>

<h3>
<a id="3-check-fermat-pseudoprime-to-base-2" class="anchor" href="#3-check-fermat-pseudoprime-to-base-2" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. CHECK FERMAT PSEUDOPRIME TO BASE 2</strong>
</h3>

<h3>
<a id="4-rabin-miller--test" class="anchor" href="#4-rabin-miller--test" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>4. RABIN-MILLER- TEST</strong>
</h3>

<p>we'll check 64 numbers, include of 20 the first primes and 44 random numbers.</p>

<h3>
<a id="5-gordons-algorithm-for-finding-strong-primes" class="anchor" href="#5-gordons-algorithm-for-finding-strong-primes" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>5. GORDON'S ALGORITHM FOR FINDING STRONG PRIMES</strong>
</h3>

<p>Gordon's algorithm is as follows:</p>

<blockquote>
<ol>
<li>Find p-- and p+ as large random primes.</li>
<li>Compute p- as the least prime of the form p-=a--*p-- +1, for some integer a--.</li>
<li>Let po=((p+)^(p- -1)- (p-)^(p+ -1))mod (p-*p+).</li>
<li>Compute p as the least prime of the from p=po+a<em>p-</em>p+, for some integer a</li>
</ol>
</blockquote>

<h3>
<a id="6-runtime-of-algorithm" class="anchor" href="#6-runtime-of-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>6. RUNTIME OF ALGORITHM</strong>
</h3>

<p>OS: ubuntu</p>

<p>Language program C++</p>

<p>Use library: NTL and GMP</p>

<p>=&gt; Generate prime numbers: 0→ 2s.</p>

<p>=&gt; Generate strong prime numbers: 1→ 3s.</p>

<h2>
<a id="ii-rsa-algorithm" class="anchor" href="#ii-rsa-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>II. RSA ALGORITHM</h2>

<h3>
<a id="1-generate-key" class="anchor" href="#1-generate-key" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>1. GENERATE KEY</strong>
</h3>

<blockquote>
<p>Generate p and q as strong primes about 3072bit.</p>

<p>Compute n=p<em>q and phi(n)=(p-1)</em>(q-1)</p>

<p>Choose e, such as gcd(e,phi(n))=1.</p>

<p>Let e*d=1 mod phi(n).</p>

<p>Private key (n,d) Public key (n,e)</p>
</blockquote>

<h3>
<a id="2-encrypt" class="anchor" href="#2-encrypt" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>2. ENCRYPT</strong>
</h3>

<p>we'll encrypt a KEY{128,192,256}. </p>

<p>Generate a array bits with size = 2048. And use 16 headbit and KEY{128,192,256}, so we have to random 2032-KEY.</p>

<p>Encrypt array bits:  C=M^e mod n</p>

<p>we should store C format base64.</p>

<h3>
<a id="3-decrypt" class="anchor" href="#3-decrypt" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>3. DECRYPT</strong>
</h3>

<p>Decryption process do the opposite encryption with M = C ^ d mode n</p>

<h1>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span class="octicon octicon-link"></span></a>References</h1>

<p>[1]. <em>Are `Strong' Primes Needed for RSA?</em>,Ronald L. Rivest #,Robert D. Silverman y
November 22, 1999</p>

<p>[2]. <em>Strong primes are easy to find</em>, John Gordon, Cybermation L t d</p>

<hr>

<hr>

<h1>
<a id="phƯƠng-phÁp-sinh-khÓa-vÀ-mÃ-hÓa-rsa" class="anchor" href="#ph%C6%AF%C6%A0ng-ph%C3%81p-sinh-kh%C3%93a-v%C3%80-m%C3%83-h%C3%93a-rsa" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>PHƯƠNG PHÁP SINH KHÓA VÀ MÃ HÓA RSA</strong>
</h1>

<p><em><a href="https://www.facebook.com/thangdn.sf">Thangdn</a> – 18.7.2015(update)</em></p>

<p><em><a href="mailto:thangdn.tlu@outlook.com">thangdn.tlu@outlook.com</a></em></p>

<p><em>ThangLong University</em></p>

<h2>
<a id="iphƯƠng-phÁp-sinh-khÓa" class="anchor" href="#iph%C6%AF%C6%A0ng-ph%C3%81p-sinh-kh%C3%93a" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.PHƯƠNG PHÁP SINH KHÓA</strong>
</h2>

<p>Theo định lý về số nguyên tố, thì khoảng cách trung bình của hai số nguyên tố lớn cỡ nbit khoảng n*ln2. Vậy trong khoảng này có khản năng cao sẽ tồn tại số nguyên tố.</p>

<hr>

<h3>
<a id="1sinh-số-ngẫu-nhiên" class="anchor" href="#1sinh-s%E1%BB%91-ng%E1%BA%ABu-nhi%C3%AAn" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.Sinh số ngẫu nhiên</h3>

<p>Ta cần tạo ra số giả ngẫu nhiên n kích thước đủ lớn cơ 3072bit. Vì được sử dụng trong mật mã nên số giả ngẫu nhiên phải đảm bảo không đoán được, không trùng nhau và cách xa nhau.</p>

<p>Trong chương trình này sử dụng hàm RandomBits()(thư viện NTL) để sinh một chuỗi ngẫu nhiên n bit đảm bảo an toàn.</p>

<h3>
<a id="2tiền-xử-lý" class="anchor" href="#2ti%E1%BB%81n-x%E1%BB%AD-l%C3%BD" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.Tiền xử lý</h3>

<p>Ta sẽ xét trong khoảng hơn 2<em>n</em>ln2 số bằng thuật toán Rabin-miller, ta có thể loại nhanh hơn các hợp số với 1000 số nguyên tố nhỏ. Qua bước xử lý này có thể loại bỏ 93% hợp số trong khoảng [n,n+2<em>n</em>ln2).</p>

<p>Các bước thực hiện:</p>

<blockquote>
<ul>
<li><p>Tạo danh sách 1000 số nguyên tố đầu tiên.</p></li>
<li><p>Với mỗi số ngẫu nhiên n, tạo một mảng bít S kích thước 2<em>n</em>ln2, khởi tạo bằng 0.</p></li>
<li><p>Với mỗi số nguyên tố p khởi tạo ban đầu, tính r=n%p. Gán tất cả các phần tử S[p<em>k-r]=1. Ta thấy rằng n+p</em>k-r luôn chia hết cho p. Như vậy những phần tử S[i]=1, ta luôn có n+i chia hết cho p.</p></li>
</ul>

<p>Sau khi kết thúc ta sẽ chỉ cần kiểm tra các phần tử n+i với S[i]=0.</p>
</blockquote>

<h3>
<a id="3kiểm-tra-số-giả-nguyên-tố-fermat-cơ-sở-2" class="anchor" href="#3ki%E1%BB%83m-tra-s%E1%BB%91-gi%E1%BA%A3-nguy%C3%AAn-t%E1%BB%91-fermat-c%C6%A1-s%E1%BB%9F-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.Kiểm tra số giả nguyên tố Fermat cơ sở 2</h3>

<p>Việc kiểm tra số giả nguyên tố fermat cơ sở 2 sẽ giúp loại được nhiều hợp số.</p>

<h3>
<a id="4kiểm-tra-rabin-miller" class="anchor" href="#4ki%E1%BB%83m-tra-rabin-miller" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.Kiểm tra Rabin-miller</h3>

<p>Với sai số của số giả nguyên tố là 2^-128, vậy nên ở đây ta sẽ thực hiện kiểm tra Rabin-miller với 128/2 cơ số khác nhau cho n, bao gồm 20 số nguyên tố đầu tiên và 44 số sinh ngẫy nhiên &lt;= căn bậc 2 của n.</p>

<h3>
<a id="5sinh-số-nguyên-tố-mạnh" class="anchor" href="#5sinh-s%E1%BB%91-nguy%C3%AAn-t%E1%BB%91-m%E1%BA%A1nh" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.Sinh số nguyên tố mạnh</h3>

<p>Với việc sinh số nguyên tố mạnh đảm bảo tính khó tấn công bằng việc phân tích nguyên tố n=p*q đối với p,q là số nguyên tố yếu. Số nguyên tố mạnh phải đảm bảo những yêu cầu sau:</p>

<blockquote>
<ul>
<li><p>Số p là một số cực lớn</p></li>
<li><p>Thừa số nguyên tố lớn nhất của p-1 là p- một số lớn.</p></li>
</ul>

<p>sao cho p=a-*p- +1 là số nguyên tố nhỏ nhất với a- tự chọn</p>

<ul>
<li>Thừa số nguyên tố lớn nhất của p- - 1 là p-- một số lớn.</li>
</ul>

<p>sao cho p-=a--*p-- + 1 là số nguyên tố nhỏ nhất với a-- tự chọn</p>

<p>Thừa số nguyên tố lớn nhất của p + 1 là p+ là số nguyên tố</p>

<p>sao cho p=a+*p+ -1 là số nguyên tố với a+ là tự chọn</p>
</blockquote>

<p>Ta sử dụng thuật toán của Gordon's cho việc tìm số nguyên tố mạnh</p>

<blockquote>
<ol>
<li><p>Tìm hai số p-- và p+ là hai số ngẫu nhiên lớn cỡ n/2bit (nbit là độ dài số nguyên tố mạnh cần tìm). Chú ý hai số này phải khác nhau hoàn toàn.</p></li>
<li><p>Tìm p- là số nguyên tố nhỏ nhất theo công thức p-=a-*p--+1</p></li>
<li><p>Tính po=((p+)^(p- -1)- (p-)^(p+ -1))mod (p-*p+).</p></li>
<li><p>Tìm p là số nguyên tố nhỏ nhất theo công thức p=po+a<em>p-</em>p+</p></li>
</ol>
</blockquote>

<h3>
<a id="6thời-gian-chạy" class="anchor" href="#6th%E1%BB%9Di-gian-ch%E1%BA%A1y" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.Thời gian chạy</h3>

<p>Qua quá trình cài đặt thuật toán bằng ngôn ngữ C++ trên hệ điều thành Ubuntu thấy tố độ như sau.</p>

<p>Sinh số nguyên tố độ dài 3072bit trong khoảng thời gian là 0-2s.</p>

<p>Sinh số nguyên tố mạnh độ dài 3072bit trong khoảng thời gian là 1-4s</p>

<p>Yêu cầu sử dụng thư viện NTL để sinh số ngẫu nhiên an toàn, và tính toán bằng thư viện GMP</p>

<h2>
<a id="iimÃ-hÓa-rsa" class="anchor" href="#iim%C3%83-h%C3%93a-rsa" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>II.MÃ HÓA RSA</strong>
</h2>

<h3>
<a id="1sinh-khóa" class="anchor" href="#1sinh-kh%C3%B3a" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.Sinh khóa</h3>

<blockquote>
<p>Sinh hai ngẫu nhiên hai số p và q cách xa nhau là hai số nguyên tố mạnh cơ 3072bit</p>

<p>Tính n=p*q</p>

<p>Tính phi(n)=(p-1)*(q-1).</p>

<p>Chọn e sao cho gcd(e, phi(n))=1</p>

<p>Tính d = e-1 mod phi(n)</p>

<p>Private key (n,d) Public key (n,e)</p>
</blockquote>

<h3>
<a id="2mã-hóa" class="anchor" href="#2m%C3%A3-h%C3%B3a" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.Mã hóa</h3>

<blockquote>
<ol>
<li><p>Mã hóa một chuỗi số có độ dài thuộc KEY{128,192,256}</p></li>
<li><p>Sinh chuỗi 2048 bit trong đó 16bit đầu là bit mặc định KEY là số bit đặt cuối, 2032-KEY là số bit giữa sẽ random.</p></li>
<li><p>Mã hóa chuỗi số 2048bit trên bởi công thức C=M^e mod n</p></li>
<li><p>Lưu C dưới dạng base64 tức gom 6bit một để tránh các ký tự điều khiển.</p></li>
</ol>
</blockquote>

<h3>
<a id="3giải-mã" class="anchor" href="#3gi%E1%BA%A3i-m%C3%A3" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.Giải mã</h3>

<p>Quy trình giải mã làm ngược lại quá trình mã hóa với M=C^d mode n</p>

<h2>
<a id="tÀi-liỆu-tham-khẢo" class="anchor" href="#t%C3%80i-li%E1%BB%86u-tham-kh%E1%BA%A2o" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>TÀI LIỆU THAM KHẢO:</em>
</h2>

<p>[1]. <em>Are `Strong' Primes Needed for RSA?</em>,Ronald L. Rivest #,Robert D. Silverman y</p>

<p>November 22, 1999</p>

<p>[2]. <em>Strong primes are easy to find</em>, John Gordon, Cybermation L t d</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/thang19xx/PrGlib">PrGlib library</a> is maintained by <a href="https://github.com/thang19xx">thang19xx</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

